
```{r plotting, include=FALSE, cache=FALSE}
opts_knit$set(upload.fun = socialR::flickr.url)
opts_chunk$set(dev.args=list(bg="transparent"), cache=TRUE, 
               cache.path = "smalltable/", comment=NA, message=FALSE, warning=FALSE)
```

```{r  setup, echo=FALSE, cache=FALSE}
require(multipleuncertainty)
require(reshape2)
require(ggplot2)
require(data.table)
require(pdgControl)
````

Define our functions 


``` {r logistic}
f <- function(x,h,p){
  sapply(x, function(x){
  	S = max(x - h, 0)
  	p[1] * S * (1 - S/p[2]) + S
  })
}
pars = c(1.5, 100)
K <- pars[2]
````

```{r }
#pars <- c(1.5, 0.05)
xmin <- 0
xmax <- 1.5 * K
n_x <- 30
n_h <- n_x
x_grid <- seq(xmin, xmax, length = n_x)  
h_grid <- seq(xmin, xmax, length = n_h)
delta <- 0.05
xT <- 0
OptTime <- 5
profit <- function(x,h) pmin(x, h)
````



# Scenarios: 

We use Monte Carlo integration over the noise processes to determine the transition matrix.  



``` {r policyscenarios}
compute_policy <- function(sigmas){ 
  z_g <- function() 1+(2*runif(1, 0,  1)-1) * sigmas[1]
  z_m <- function() 1+(2*runif(1, 0,  1)-1) * sigmas[2]
  z_i <- function() 1+(2*runif(1, 0,  1)-1) * sigmas[3]

 out <- 
  SDP_multiple_uncertainty(f, pars, x_grid, h_grid, OptTime,
                           sigmas = sigmas, pdfn=pdfn)
  list(D = out$D, V=out$V)
}
````

``` {r beparallel, cache=FALSE, eval=FALSE}
require(snowfall)
sfInit(parallel=TRUE, cpu=4)
sfLibrary(multipleuncertainty)
sfExportAll()
````

Determine the policies for each of the scenarios (noise combinations).

``` {r runall}
set <- list(det = c(0, 0, 0), g = c(0.3, 0, 0), m = c(0, 0.3, 0), all = c(0.3, 0.3, 0.3))
scenarios <- lapply(set, compute_policy)
```


```{r }
policies <- sapply(scenarios, function(out) out$D[,1])
values <- sapply(scenarios, function(out) out$V)
````


### plots


```{r policy-data}
policy <- melt(data.frame(cbind(stock = x_grid, policies)), id = "stock")
```

```{r sethiplots-escapement}
ggplot(policy) + 
  geom_point(aes(stock, stock-x_grid[value], color=variable), shape='+') +
	stat_smooth(aes(stock, stock-x_grid[value], color=variable), 
              degree=1, se=FALSE, span=0.3) +
  ylab("escapement") 
```

```{r sethiplots-harvest}
ggplot(policy) +
  geom_point(aes(stock, x_grid[value], color=variable), shape='+') +
	stat_smooth(aes(stock, x_grid[value], color=variable),
              degree=1, se=FALSE, span=0.3) +
  ylab("harvest") 
```


```{r value-data}
# value <- melt(data.frame(cbind(stock = x_grid,values)), id = "stock")
# ggplot(value) + 
#  geom_point(aes(stock, value, color=variable), shape='+') +
#  stat_smooth(aes(stock, value, color=variable),
#    degree=0, se=FALSE, span=0.15) +
#  ylab("Net Present Value")
````



## Simulations

``` {r simfn, dependson="policy-data"} 
simulatereps <- function(opt, sigmas){

  z_g <- function() 1+(2*runif(1, 0,  1)-1) * sigmas[1]
  z_m <- function() 1+(2*runif(1, 0,  1)-1) * sigmas[2]
  z_i <- function() 1+(2*runif(1, 0,  1)-1) * sigmas[3]

  sims <- lapply(1:100, function(i){
    ForwardSimulate(f, pars, x_grid, h_grid, x0 = K, opt$D, z_g, z_m, z_i, profit)
  })
  
  sims
}
````


All cases

``` {r runallsims, dependson="simfn"} 
policyfn <- sapply(scenarios, function(out) out)  # consider driving with stationary policy ...
allcases <- lapply(policyfn, function(policyfn_i){
  lapply(set, function(sigmas){
    simulatereps(policyfn_i, sigmas)
  })
})
````

``` {r tidyall, dependson="runallsims"}
sims <- unlist(allcases, recursive=FALSE)
dat <- melt(sims, id=names(sims[[1]][[1]]))  
dt <- data.table(dat)
setnames(dt, c("L2", "L1"), c("reps", "uncertainty")) # names are nice
````


### Plots 


``` {r  onerep, dependson="tidyall"}
ggplot(subset(dt,reps==1)) +
  geom_line(aes(time, fishstock)) +
  geom_line(aes(time, harvest), col="darkgreen") + 
  facet_wrap(~uncertainty) 
````

Summary statistics 

``` {r summarystats, cache=FALSE}
means <- profits[, mean(V1), by=uncertainty]
sds <- profits[, sd(V1), by=uncertainty]
````

``` {r prettytable, cache=FALSE, results="asis"}
require(xtable)
uncertainties <- names(noise) 
print(xtable(matrix(means$V1, nrow=length(noise), dimnames=list(uncertainties, uncertainties))), type="html")
print(xtable(matrix(sds$V1, nrow=length(noise), dimnames=list(uncertainties, uncertainties))), type="html")
````


