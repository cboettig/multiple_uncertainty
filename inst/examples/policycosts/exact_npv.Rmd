`ro warning=FALSE, message=FALSE, comment=NA, cache=TRUE, cache.path="exact.npv/" or`

``` {r setup, include=FALSE }
#opts_knit$set(upload.fun = socialR::flickr.url)
````


 * author Carl Boettiger, <cboettig@gmail.com>
 * license: CC0

## Setup the system
``` {r libraries }
rm(list=ls())   
require(pdgControl)
require(reshape2)
require(ggplot2)
require(data.table)
````

``` {r pars  }
delta <- 0.05     # economic discounting rate
OptTime <- 50     # stopping time
gridsize <- 50   # gridsize (discretized population)
sigma_g <- 0.2    # Noise in population growth
sigma_m <- 0.     # noise in stock assessment measurement
sigma_i <- 0.     # noise in implementation of the quota
reward <- 0       # bonus for satisfying the boundary condition
````



``` {r noise_dists }
z_g <- function() rlnorm(1,  0, sigma_g) # mean 1
z_m <- function() 1
z_i <- function() 1
````



``` {r BevHolt_ }
f <- BevHolt                # Select the state equation
pars <- c(1.5, 0.05)             # parameters for the state equation
K <- (pars[1] - 1)/pars[2]  # Carrying capacity (for reference 
xT <- 0                     # boundary conditions
x0 <- K
````

``` {r profit_ }
profit <- profit_harvest(price = 10, c0 = 30, c1 = 0)
````

``` {r create_grid_ }
x_grid <- seq(0.01, 1.2 * K, length = gridsize)  
h_grid <- seq(0.01, 0.8 * K, length = gridsize)  
````

## Declare the different penalty norms

``` {r fees }
L1 <- function(c2) function(h, h_prev)  c2 * abs(h - h_prev) 
asymmetric <- function(c2) function(h, h_prev)  c2 * max(h - h_prev, 0)
fixed <-  function(c2) function(h, h_prev) c2 * as.numeric( !(h == h_prev) )
L2 <- function(c2) function(h, h_prev)  c2 * (h - h_prev) ^ 2
free_increase <- function(c2) function(h, h_prev)  c2 * abs(min(h - h_prev, 0)) # increasing harvest is free
````

Calculate the transition matrix and intialize the the list of penalty functions and cost levels we will be looping over.

``` {r  SDP}
SDP_Mat <- determine_SDP_matrix(f, pars, x_grid, h_grid, sigma_g )
penaltyfns <- list(L2=L2, L1=L1, asy=asymmetric, fixed=fixed, asy2=free_increase)
c2 <- seq(0, 10, length.out = 30)
````

This can take a while, so we use explicit parallelization, 
``` {r  parallel}
require(snowfall)
sfInit(cpu=3, parallel=T)
sfLibrary(pdgControl)
sfExportAll()
````

## Loop over penalty functions and magnitudes


``` {r  bigloop}
policies <- 
sfSapply(penaltyfns, function(penalty){
  policies <- 
  sapply(c2, function(c2){
      policycost <- optim_policy(SDP_Mat, x_grid, h_grid, OptTime, xT, 
                        profit, delta, reward, penalty = penalty(c2))
      i <- which(x_grid > K)[1]
      max(policycost$penalty_free_V[i,]) 
  })
})
````

Note that `optim_policy` has been updated to return the equilibrium value of profits from fish harvests before the adjustment costs have been paid, `penalty_free_V`.  This containst the values for all possible states, we simply evaluate it at the carrying capacity (which is our initial condition.)  The index in `x_grid` that corresponds to the carrying capacity (initial condition) `i` indicates this.  



Quadratic costs on fishing effort have to be done separately,

``` {r  quadcosts}
quad <- 
  sapply(c2, function(c2){
  effort_penalty = function(x,h) .1*c2*h/x
  policycost <- optim_policy(SDP_Mat, x_grid, h_grid, OptTime, xT, 
                        profit, delta, reward, penalty = fixed(0), 
                        effort_penalty)
      i <- which(x_grid > K)[1]
      max(policycost$penalty_free_V[i,]) # chooses the most sensible harvest in t=1
})
dat <- cbind(policies, quad)
````

Tidy up the data and plot the net present value (before the penalty has been paid) relative to that achieved when managed without a penalty.  

``` {r npv-plot}
npv0 <- dat[1,3] 
npv0
dat <- data.frame(c2=c2,dat)
dat <- melt(dat, id="c2")
ggplot(dat, aes(c2, value, col=variable)) + geom_point() + geom_line()
````

Find the value of `c2` that brings each penalty closest to 75% of the cost-free adjustment value:

```{r comparison_plot}
ggplot(dat, aes(c2, (npv0-value)/npv0, col=variable)) + geom_point() + geom_line()
````

```{r numeric_value}
closest <- function(x, v){
	which.min(abs(v-x))
}
dt <- data.table(dat)
index <- dt[,closest(.25, (npv0-value)/value), by=variable]
cbind(index, c2=c2[index$V1])
````



